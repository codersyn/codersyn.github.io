---
title: 泰拉瑞亚修改教程-脚本篇
date: 2022-02-17 10:27:38
tags:
---

> 这是泰拉瑞亚修改教程的第二章，上接[第一章](https://synblog.gq/2021/10/03/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A%E4%BF%AE%E6%94%B9%E6%95%99%E7%A8%8B/)，如果你还没有看过相关教程，可以从头看起。

## 第二章 — 利用脚本进行复杂的修改

### 一击必杀功能

一击必杀的功能其实直接修改武器伤害为9999也可以实现，但是特殊情况下就会失效，比如面对地牢守卫时，你的每次攻击永远只能对它造成1滴血的伤害，这就导致了无论你修改多高的伤害打到它的身上也只会扣1滴血。

<img title="" src="https://s4.ax1x.com/2022/02/17/H4OweP.png" alt="地牢守卫" data-align="center">

既然高伤害不能实现秒杀，那就换一个思路，我们知道当你攻击一个怪物时，是两个触发事件，第一你的武器摸到了怪物，第二怪物扣除相应的血量，第一个不用研究，第二个怪物扣除血量我们可以改为当攻击到怪物后，不管怪物的血量是多少直接把怪物的血量变为0，变为0那当然就死了。下面是实现方法：

首先找到怪物的血值地址，随便找个怪物查看它的当前血量，这里史莱姆为例：

<img src="https://s4.ax1x.com/2022/02/17/H5ierF.png" title="" alt="怪物血值" data-align="center">

可看到史莱姆的血量为120，那在CE里搜索4字节的120数值看看：

<img src="https://s4.ax1x.com/2022/02/17/H5VQcq.png" title="" alt="CE界面" data-align="center">

看到结果还有很多，那再过滤一下，回到游戏攻击一下史莱姆：

<img title="" src="https://s4.ax1x.com/2022/02/17/H5ZadS.png" alt="游戏界面" data-align="center">

攻击一下扣了2滴血，返回CE继续搜索118：

<img src="https://s4.ax1x.com/2022/02/17/H5ZLdO.png" title="" alt="CE界面" data-align="center">

可以看到此时只有一个结果了，右键这个地址，**查看是什么改写了这个地址**：

<img src="https://s4.ax1x.com/2022/02/17/H5e26I.png" title="" alt="CE界面" data-align="center">

回到游戏，再攻击一下史莱姆，然后返回CE，应该可以看到列表里多了一个地址，点击**Show disassembler**打开内存浏览界面：

<img src="https://s4.ax1x.com/2022/02/17/H5mN4g.png" title="" alt="CE界面" data-align="center">

然后在这个地址上右键，复制其模块地址：

<img src="https://s4.ax1x.com/2022/02/17/H5n4Jg.png" title="" alt="CE界面" data-align="center">

然后点击**Tools** -> **Auto Assemble**：

<img src="https://s4.ax1x.com/2022/02/17/H5uSSJ.png" title="" alt="CE界面" data-align="center">

再点击**Template** -> **Full Injection**，然后框内粘贴刚才复制的模块地址：

<img src="https://s4.ax1x.com/2022/02/17/H5Kd8e.png" title="" alt="CE界面" data-align="center">

然后分析下代码：

```java
{ Game   : Terraria.exe
  Version: 
  Date   : 2022-02-17
  Author : admin

  This script does blah blah blah
}

define(address,Terraria.NPC::StrikeNPC+742)
define(bytes,29 86 00 01 00 00)

[ENABLE]

assert(address,bytes)
alloc(newmem,$1000)

label(code)
label(return)

newmem:

code:
  sub [esi+00000100],eax
  jmp return

address:
  jmp newmem
  nop
return:

[DISABLE]

address:
  db bytes
  // sub [esi+00000100],eax

dealloc(newmem)
```

定位到`sub [esi+00000100],eax`，这段的意思是从`[esi+00000100]`这个指针地址里减去`eax`，因为我们是攻击怪物的时候触发的这个地址，所以很可能`[esi+00000100]`就是怪物的血值地址，而`eax`即扣除的血量数值。

既然怀疑，就尝试修改一下，因为`sub [esi+00000100],eax`的意思是从怪物血值里减去受到的伤害值，那我们注释掉原来的`sub [esi+00000100],eax`，改为`mov [esi+00000100],0`，这段意思是，把0这个值移到怪物血值里，这样当我们攻击怪物的时候触发的就是把0移到他的血量里面，相当于血量直接变为0，也就达到了秒杀效果：<img src="https://s4.ax1x.com/2022/02/18/HTBFoV.png" title="" alt="CE界面" data-align="center">

然后保存脚本：

<img src="https://s4.ax1x.com/2022/02/18/HTD3Bn.png" title="" alt="CE界面" data-align="center">

接着激活脚本：

<img src="https://s4.ax1x.com/2022/02/18/HTyTER.png" title="" alt="CE界面" data-align="center">

最后进入游戏看看有无效果：

<img src="https://s4.ax1x.com/2022/02/18/HTcN6S.gif" title="" alt="一击必杀效果" data-align="center">

可以看到满血史莱姆一镐子就没了，当然不止史莱姆，任何怪物都是一击必杀，因为懒的原因我就不去找其他怪物试刀了，你们可以自行测试。

到这里一击必杀的效果就做出来了，而且不是修改高伤害那种**伪·一击必杀**，其实游戏修改很简单，难点在于思路，只要找对了思路，问题就会迎刃而解，当然也需要一些汇编基础才能看懂代码，但是最重要的还是思路。

### 无敌功能

既然我们拥有了最强的矛，那当然也得拥有最强的盾不是，和一击必杀类似，也有**伪·无敌**，找到人物血量基址，然后锁定血量即可达到受伤秒回复的效果，但是这样有个弊端就是如果遇到伤害很高的怪物，或者怪物群殴你的时候，就很有可能血量还没回复就被敌人秒杀了，所以不算真正的无敌，那么如何实现真正的无敌呢。

同样的，当我们被攻击的时候也是两个触发事件，第一怪物或者怪物的技能碰到了我们的角色，第二我们的角色扣除相应的血量。看到这里是不是很熟悉，你说那我是不是可以根据第二个触发事件来修改，当怪物触碰到我们的时候，把那个受到的伤害值改为0？这样每次受到攻击都是无效的0点伤害，当然可以，你甚至还能把那个扣血的事件改为加血事件，这样当怪物攻击你的时候，你不仅不掉血，而且还加血，这样每个怪物在你眼里就成了无数个奶妈。

那下面试着实现一下这两个思路，首先找到角色的血量地址，进入游戏，查看当前的血量，可看到我当前的血量是79：

<img src="https://s4.ax1x.com/2022/02/18/HTxhHH.png" title="" alt="角色当前血量" data-align="center">

返回CE搜索4字节的79：

<img src="https://s4.ax1x.com/2022/02/18/HTzEb4.png" title="" alt="CE界面" data-align="center">

还有很多结果，返回游戏让怪物攻击一下，再查看当前血量变成了61：

<img src="https://s4.ax1x.com/2022/02/18/HTz4MT.png" title="" alt="当前血量" data-align="center">

返回CE，搜索61，看到还剩两个结果：

<img src="https://s4.ax1x.com/2022/02/18/H7SuwQ.png" title="" alt="CE界面" data-align="center">

通过修改血量数值判断出第二个为角色血量地址：

<img src="https://s4.ax1x.com/2022/02/18/H7pWuT.png" title="" alt="CE界面" data-align="center">

右键该地址，**查看是什么改写了这个地址**：

<img src="https://s4.ax1x.com/2022/02/18/H799PA.png" title="" alt="CE界面" data-align="center">

返回游戏，让怪物攻击一下，再返回CE，此时看到多了一个地址：

<img src="https://s4.ax1x.com/2022/02/18/H7CpeU.png" title="" alt="" data-align="center">

其实到这里，和一击必杀的步骤都是一样的，根据那个步骤操作就行，这里咱们直接快进到代码部分：

```java
{ Game   : Terraria.exe
  Version: 
  Date   : 2022-02-18
  Author : admin

  This script does blah blah blah
}

define(address,Terraria.Player::Hurt+1177)
define(bytes,29 82 E4 03 00 00)

[ENABLE]

assert(address,bytes)
alloc(newmem,$1000)

label(code)
label(return)

newmem:

code:
  sub [edx+000003E4],eax
  jmp return

address:
  jmp newmem
  nop
return:

[DISABLE]

address:
  db bytes
  // sub [edx+000003E4],eax

dealloc(newmem)
```

定位到`sub [edx+000003E4],eax`，如果你认真学习了一击必杀那个功能的实现，那你现在肯定知道`[edx+000003E4]`就是角色血量的地址，而`eax`即为受到的伤害值，`sub`是一个汇编指令，表示**减**，之前的`mov`代表**数据传送**，下面马上要用到的`add`表示**加**，其实很好理解，根据字面意思大概都能猜出来。那么这段的意思就是从当前血量里扣除受到的伤害值，我现在把`eax`改为0，那是不是就代表着，每次受到攻击都是0伤害值？

注释掉`sub [edx+000003E4],eax`，增加一条语句为`sub [edx+000003E4],0`：

<img src="https://s4.ax1x.com/2022/02/18/H7FQkF.png" title="" alt="" data-align="center">

接着保存并激活脚本，进入游戏看看效果：

<img src="https://s4.ax1x.com/2022/02/18/H7kMut.gif" title="" alt="无敌效果" data-align="center">

可以看到虽然还是有显示受到的伤害数字，但是并不会掉血，无敌效果①达成。

下面试下另一个效果，其实也很简单，只需要改动一点点代码：

<img src="https://s4.ax1x.com/2022/02/18/H7A6df.png" title="" alt="" data-align="center">

可以看到原代码为`sub [edx+000003E4],eax`，代表从血值里扣掉受到的伤害值，之前我们改为`sub [edx+000003E4],0`，就表示从血值里扣掉0点伤害值，相当于不受伤，现在我们改为`add [edx+000003E4],1`，表示受到伤害时，把1加到血值里面，这样每次受到攻击都会加1滴血。

保存并激活脚本，进游戏看看效果：

<img src="https://s4.ax1x.com/2022/02/18/H7Vfrn.gif" title="" alt="无敌效果2" data-align="center">

很好，无敌效果②达成。

但是会发现，有两个不完美的地方：①会显示受到伤害的数字，明明都已经无敌了，还显示个毛的伤害数字啊；②受到攻击时虽然不掉血，但是会被怪物撞得跳来跳去的，明明都已经无敌了，你这还疼得跳来跳去的算什么事啊？

那么问题来了，有第三种无敌方法吗？

俗话说得好，**只要思想不滑坡，办法总比困难多**，开头的时候说过，当被攻击的时候触发的是两个事件，一被怪物触碰到，二扣除所受伤害值的血量，我们根据第二个事件研究出了两个无敌思路，现在研究第一个事件，因为我们是先被怪物触碰到然后才会触发扣血的事件，那么如果移除这个碰撞事件，是不是就不会受到伤害了？

前面我们找到了扣血函数的地址：`Terraria.Player::Hurt+1177`，现在我们在这个地址下断点，看看能否找到关于碰撞的函数：

<img src="https://s4.ax1x.com/2022/02/19/HHQWod.png" title="" alt="" data-align="center">

下断点后返回游戏，随便找个怪挨打一下，挨打后会发现游戏被断下了，那证明这个地址有戏，分析一下，因为是先挨打再扣血，而我们是直接在扣血地址下的断点，那这个call大概率只是处理一些扣血以及死亡的函数，我们点击**Step Out**跳出这个call：

<img src="https://s4.ax1x.com/2022/02/19/HH8Zfs.png" title="" alt="" data-align="center">

跳出这个call后来到这个地址：

<img src="https://s4.ax1x.com/2022/02/19/HH8Lj0.png" title="" alt="" data-align="center">

这里我们发现上面这个地址call了`Terraria.Player::Hurt`，根据翻译猜测这个`Terraria.Player::Hurt`应该是处理角色受到伤害的一个总函数，那我们直接nop掉这个地址是不是就不会受到碰撞伤害了呢：

<img src="https://s4.ax1x.com/2022/02/19/HHJEzn.png" title="" alt="" data-align="center">

`nop`会提示该地址长度为6字节，但是`nop`只有一个字节，点yes会自动填充剩下的5字节。然后点**Run**再回游戏看看效果：

<img src="https://s4.ax1x.com/2022/02/19/HHJ5Wj.gif" title="" alt="" data-align="center">

可以看到已经移除了碰撞检测，那我们还原刚才`nop`的代码，通过编写脚本来达到目的，和之前一样，复制其模块地址，然后编写脚本：

```java
{ Game   : Terraria.exe
  Version: 
  Date   : 2022-02-19
  Author : admin

  This script doe blah blah blah
}

define(address,Terraria.Player::Update_NPCCollision+7A1)
define(bytes,E8 8A FE D9 FF)

[ENABLE]

assert(address,bytes)
alloc(newmem,$1000)

label(code)
label(return)

newmem:

code:
  call Terraria.Player::Hurt
  jmp return

address:
  jmp newmem
return:

[DISABLE]

address:
  db bytes
  // call Terraria.Player::Hurt

dealloc(newmem)
```

刚才我们是直接`nop`掉达到了目的，那么脚本如何编写呢，其实很简单，注释掉`call Terraria.Player::Hurt`就行了，注释掉就不会执行这个call：

<img src="https://s4.ax1x.com/2022/02/19/HHtd8H.png" title="" alt="" data-align="center">

和之前一样，保存脚本，然后激活脚本进游戏测试效果：

<img src="https://s4.ax1x.com/2022/02/19/HHt5Mn.png" title="" alt="" data-align="center">

到这里，无敌功能就算是完美了，涉及到一些新东西如下断点，nop，call等等都是汇编知识，感兴趣的可以找相关书籍看看，也不用深究，这玩意学多了脑壳疼，单纯的写写修改器有点基础就够了，写修改器最重要的是思路。

### 极速

   累了，歇会再写。
